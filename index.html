<!DOCTYPE html>
<html lang="jp">
<head>
<meta charset="UTF-8">

<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script src="https://unpkg.com/textalive-app-api/dist/index.js"></script>
<script type="module">

const suits = ["heart", "spade", "diamond", "club"];

function updateCardText(suit, newText){
    document.getElementById(`${suit}-cardtext-style`).textContent = `.${suit}-card > .cardtext::after{ content: "${newText}" }`
}

function pauseAnimation(){
  document.getElementById("animation-state").textContent=".deck-position{animation-play-state: paused;} .card{animation-play-state: paused;}"
}

function playAnimation(){
  document.getElementById("animation-state").textContent=".deck-position{animation-play-state: running;} .card{animation-play-state: running;}"
}

function resetAnimation() {
  pauseAnimation();
  // To reset the animation, we remove the classes containing them, trigger reflow, then add them back in
  for (const element of document.getElementsByClassName("deck-position")) {
    element.classList.remove("deck-position");
    element.offsetWidth;
    element.classList.add("deck-position");
  };
  for (const element of document.getElementsByClassName("card")) {
    element.classList.remove("card");
    element.offsetWidth;
    element.classList.add("card");
  };
  suits.forEach((suit) => updateCardText(suit, "Q"));
}

function appendWord(currentString, newWord){
  // English words should have spaces in between
  if (newWord.language == "en") {
    if (currentString.endsWith(" ")){
      return currentString + newWord.text + " ";
    }
    else {
      return currentString + " " + newWord.text + " ";
    }
  }
  else {
    return currentString + newWord.text;
  }
}

const { Player } = TextAliveApp;

var hasStarted = false;
var lastText = null;
var lastEndTime = 0;
var currentWord;

var beatText = Array();

const player = new Player({
  app: { token: "" },
  mediaElement: document.querySelector("#media"),
  mediaBannerPosition: "top left"
});

player.addListener({

  onAppReady(app) {
    if (app.managed) {
      document.querySelector("#header").className = "disabled";
    }
    if (!app.songUrl) {
      player.createFromSongUrl("https://piapro.jp/t/ucgN/20230110005414", {
        video: {
          beatId: 4267297,
          chordId: 2405019,
          repetitiveSegmentId: 2405019,
          lyricId: 56092,
          lyricDiffId: 9636
        }
      });
    }
  },

  onTimerReady() {
    document.querySelector("#play").className="";
    document.querySelector("#volume").className="";
    document.querySelector("#loading").className="disabled";
  },

  onVideoReady: (v) => {
    // Building up the lookup table for beats to card text
    // The text for a beat is usually the concatenation of all words
    // starting within that beat.
    // If a word doesn't end within the next beat, repeat the text until
    // it does.
    let currentWord = v.firstWord;

    // For aesthetics (so on load the cards look like actual cards),
    // until lyrics start the card text should be Q, because Miku is
    // our Queen :)
    let lastText = "Q";
    let lastEndTime = currentWord.startTime;
    for (const currentBeat of player.getBeats()) {
      // The last text covers over this whole beat, extend it
      if (lastEndTime > currentBeat.endTime) {
        beatText.push(lastText);
        continue;
      }
      // The last text ends on this beat, reset it and collect
      // words starting on this one (there may not be any)
      lastText = "";
      while (currentWord && currentWord.startTime <= currentBeat.endTime) {
        lastText = appendWord(lastText, currentWord);
        lastEndTime = currentWord.endTime;
        currentWord = currentWord.next;
      }
      beatText.push(lastText);
    }
    // Export for debugging
    console.log(beatText.length);
    window.beatText = beatText;
  },

  onPlay() {
    playAnimation();
    document.querySelector("a#play").textContent = "⏸︎";
  },

  onPause() {
    pauseAnimation();
    document.querySelector("a#play").textContent = "⏵";
    // There doesn't seem to be an event for the track end,
    // it just calls pause. Sometimes there will be a seek
    // to the beginning before this callback runs.
    // Sometimes the pause doesn't even happen at the very end of
    // playback. Use a 100ms tolerance.
    if (player.mediaPosition >= (player.video.duration - 100) || player.mediaPosition === 0) {
      resetAnimation();
    }
  },

  onStop() {
    resetAnimation();
  },

  onMediaSeek(position){
  },
  
  onTimeUpdate(position) {
    // Draw the current and next beat
    let currentBeat = player.findBeat(position);
    this.drawBeat(currentBeat);
    this.drawBeat(currentBeat.next);
  },

  drawBeat(beat) {
    let currText = beatText[beat.index];
    // Lag the display a bit, so that the
    // text goes on the card under the one
    // currently moving
    let currSuit = suits[(beat.index + 1) % 4];
    updateCardText(currSuit, currText);
  }
});

// Setting up controls
document.querySelector("a#play").addEventListener("click", (e) => {
  e.preventDefault();
  if (player) {
    if (player.isPlaying) {
      player.requestPause();
    }
    else {
      player.requestPlay();
    }
  }
  return false;
});

document.querySelector("a#stop").addEventListener("click", (e) => {
  e.preventDefault();
  if (player) {
    player.requestStop();
  }
  resetAnimation();
  return false;
})

document.querySelector("#volume-slider").addEventListener("input", (e) => {
  if (player) {
    player.volume = e.target.value;
  }
})
</script>

<style>
  :root {
    --bpm: 134;
    --sec-per-beat: calc(60s / var(--bpm));
  }
    @keyframes throw {
      25% {
        z-index: 1;
        offset-distance: 0%;
        offset-rotate: 0deg;
      }
      100% {
        z-index: 0;
        offset-distance: 100%;
        offset-rotate: 70deg;
      }
    }
    @keyframes bounce {
      50% {
        transform: translateY(20px) rotateX(18deg) rotateY(21deg) rotateZ(-29deg);
      }
    }
    body::before {
      content: "";
      position: absolute;
      width: 1200vw;
      height: 700vw;
      top: -250vw;
      left: -350vw;
      z-index: -1;
      background: url("images/background_tile.png") top left repeat;
      transform: skew(10deg, 20deg);
    }
    body {
      margin: 0px;
      overflow: hidden;
    }

    .disabled {
      display: none;
    }

    .deck-position {
        position: absolute;
        top: 300px;
        left: 25%;
        transform: rotateX(18deg) rotateY(21deg) rotateZ(-29deg);
        transform-style: preserve-3d;
        animation: bounce var(--sec-per-beat) ease-in-out infinite;
        animation-delay: 0.25s;
    }
    .card {
        display: block;
        position: absolute;
        width: 300px;
        height: 420px;
        border: 1px solid black;
        margin: 0px;
        background-color: rgb(230, 221, 221);
        transform: translateZ(50px);
        offset-path: path("M 150 210 C 559 58 1323 166 3165 914");
        /* The offset path can't start at (0, 0), that would put the centre of the card in
        the top-left corner of the deck. But starting it at (width/2, height/2) also rotates it,
        because offset-path defaults to rotating things to line up with the path. This is
        actually useful for the animation, so it shouldn't be disabled. The solution is to
        undo that initial rotation, which has a value of atan(height/width) */
        offset-rotate: 0deg;
        animation: throw calc(4 * var(--sec-per-beat)) ease-in infinite;
    }
    .deck-front {
      display: block;
      position: absolute;
      width: 300px;
      height: 100px;
      top: 470px;
      border: 1px solid black;
      transform: rotateX(90deg) translateZ(100px);
      background-color: rgb(185, 178, 178);
    }
    .deck-right {
      display: block;
      position: absolute;
      width: 100px;
      height: 420px;
      left: -100px;
      border: 1px solid black;
      transform: rotateY(90deg) translateZ(50px);
      background-color: rgb(185, 178, 178);
    }
    .cardtext {
        font-size: 1.75em;
        white-space: nowrap;
        font-family: serif;
    }
    .cardtext::before {
      font-size: 1.5em;
    }
    .cardtext-top {
        position: relative;
        left: 10px;
        top: 0px;
        height: 0px;
        width: 0px;
    }
    .cardtext-bottom {
        position: relative;
        top: calc(100%);
        left: calc(100% - 10px);
        transform: rotate(180deg);
        height: 0px;
        width: 0px;
    }
    .image-zone {
        position: relative;
        width: 210px;
        height: 294px;
        left: 45px;
        top: 63px;
        border: 1px solid black;
    }

    .heart-card {
      animation-delay: calc(0 * var(--sec-per-beat));
    }
    .heart-card > .cardtext::before {
      content: "♥ ";
    }
    .heart-card > .cardtext {
      color: rgb(197, 32, 32);
    }

    .diamond-card {
      animation-delay: calc(2 * var(--sec-per-beat));
    }
    .diamond-card > .cardtext::before {
      content: "♦ ";
    }
    .diamond-card > .cardtext {
      color: rgb(197, 32, 32);
    }

    .club-card {
      animation-delay: calc(3 * var(--sec-per-beat));
    }
    .club-card > .cardtext::before {
      content: "♣ ";
    }
    .club-card > .cardtext {
      color: rgb(0, 0, 0);
    }

    .spade-card {
      animation-delay: calc(1 * var(--sec-per-beat));
    }
    .spade-card > .cardtext::before {
      content: "♠ ";
    }
    .spade-card > .cardtext {
      color: rgb(0, 0, 0);
    }

    #header {
      font-size: 3em;
      position: absolute;
      top: 50px;
      font-family: monospace;
      background-color: rgb(0, 0, 0, .5);
      padding: 15px;
      color: rgb(197, 32, 32);
    }
    #header > a {
      vertical-align: middle;
      padding: 15px;
      color: rgb(197, 32, 32);
      text-decoration: none;
    }
    #header > a:hover {
      color: rgb(233, 38, 38);
    }
    #loading {
      font-family: fantasy;
    }
    #volume {
      vertical-align: middle;
      width: 50px;
    }
    #volume-slider {
      vertical-align: middle;
      accent-color: rgb(233, 38, 38);
    }
</style>

<!--One-lining these, they'll be replaced with JS during the animation -->
<style id="heart-cardtext-style">.heart-card > .cardtext::after{ content: "Q" }</style>
<style id="diamond-cardtext-style">.diamond-card > .cardtext::after{ content: "Q" }</style>
<style id="club-cardtext-style">.club-card > .cardtext::after{ content: "Q" }</style>
<style id="spade-cardtext-style">.spade-card > .cardtext::after{ content: "Q" }</style>
<style id="animation-state">.deck-position{animation-play-state: paused;} .card{animation-play-state: paused;}</style>

</head>

<body>
  <div id="media"></div>
  <div id="header">
    <a href="#" id="play" class="disabled">⏵</a>
    <a href="#" id="stop" class="disabled">⏹</a>
    <span id="volume" class="disabled">🔊&#xFE0E; <input type="range" id="volume-slider" min="0" max="100" value="80"><label for="volume"></label></span>
    <span id="loading">loading...</span>
  </div>
  <div class="deck-position">
    <div class="card club-card">
      <div class="cardtext cardtext-top"></div>
      <div class="cardtext cardtext-bottom"></div>
      <div class="image-zone club-image"></div>
    </div>
    <div class="card diamond-card">
      <div class="cardtext cardtext-top"></div>
      <div class="cardtext cardtext-bottom"></div>
      <div class="image-zone diamond-image"></div>
    </div>
    <div class="card spade-card">
      <div class="cardtext cardtext-top"></div>
      <div class="cardtext cardtext-bottom"></div>
      <div class="image-zone spade-image"></div>
    </div>
    <div class="card heart-card">
      <div class="cardtext cardtext-top"></div>
      <div class="cardtext cardtext-bottom"></div>
      <div class="image-zone heart-image"></div>
    </div>
    <div class="deck-front"></div>
    <div class="deck-right"></div>
  </div>
</body>
</html>