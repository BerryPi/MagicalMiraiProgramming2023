<!DOCTYPE html>
<html>
<head>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script src="https://unpkg.com/textalive-app-api/dist/index.js"></script>
<script type="module">

const suits = ["spade", "diamond", "club", "heart"];

function updateCardText(suit, newText){
    document.getElementById(`${suit}-cardtext-style`).textContent = `.${suit}-card > .cardtext::after{ content: "${newText}" }`
}

function pauseAnimation(){
  document.getElementById("animation-state").textContent=".deck-position{animation-play-state: paused;} .card{animation-play-state: paused;}"
}

function playAnimation(){
  document.getElementById("animation-state").textContent=".deck-position{animation-play-state: running;} .card{animation-play-state: running;}"
}

function resetAnimation() {
  pauseAnimation();
  // To reset the animation, we remove the classes containing them, trigger reflow, then add them back in
  for (const element of document.getElementsByClassName("deck-position")) {
    element.classList.remove("deck-position");
    element.offsetWidth;
    element.classList.add("deck-position");
  };
  for (const element of document.getElementsByClassName("card")) {
    element.classList.remove("card");
    element.offsetWidth;
    element.classList.add("card");
  };
  suits.forEach((suit) => updateCardText(suit, "Q"));
}

function appendWord(currentString, newWord){
  // English words should have spaces in between
  if (newWord.language == "en") {
    if (currentString.endsWith(" ")){
      return currentString + newWord.text + " ";
    }
    else {
      return currentString + " " + newWord.text + " ";
    }
  }
  else {
    return currentString + newWord.text;
  }
}

const { Player } = TextAliveApp;

var hasStarted = false;
var lastText = null;
var lastEndTime = 0;
var currentWord;

const player = new Player({
  app: { token: "" },
  mediaElement: document.querySelector("#media"),
  mediaBannerPosition: "bottom left"
});

player.addListener({

  onAppReady(app) {
    if (app.managed) {
      document.querySelector("#header").className = "disabled";
    }
    if (!app.songUrl) {
      player.createFromSongUrl("https://piapro.jp/t/ucgN/20230110005414", {
        video: {
          beatId: 4267297,
          chordId: 2405019,
          repetitiveSegmentId: 2405019,
          lyricId: 56092,
          lyricDiffId: 9636
        }
      });
    }
  },

  onTimerReady() {
    document.querySelector("#play").className="";
    document.querySelector("#stop").className="";
    document.querySelector("#loading").className="disabled";
  },

  onVideoReady: (v) => {
    currentWord = v.firstWord;
    lastText = "Q";
    lastEndTime = currentWord.startTime;
  },

  onPlay() {
    playAnimation();
    document.querySelector("a#play").textContent = "⏸︎";
  },

  onPause() {
    pauseAnimation();
    document.querySelector("a#play").textContent = "⏵";
    // There doesn't seem to be an event for the track end,
    // it just calls pause. Sometimes there will be a seek
    // to the beginning before this callback runs.
    if (player.mediaPosition >= player.video.duration || player.mediaPosition === 0) {
      resetAnimation();
    }
  },

  onStop() {
    resetAnimation();
  },

  onMediaSeek(position){
  },
  
  onTimeUpdate(position) {
    // We might have reset, assume we have if lastEndTime is more than 5s ahead
    // Oddly there doesn't seem to be a way to listen for a reset; onStop is only
    // called if it happens while playing, but not while paused.
    if (lastEndTime > position + 5000){
      lastEndTime = player.video.firstWord.startTime;
    }
    // Peek two beats ahead
    let currentBeat = player.findBeat(position).next.next;
    let currentString = "";
    // Get all the words starting on the current beat
    while (currentWord && currentWord.startTime <= currentBeat.endTime){
      currentString = appendWord(currentString, currentWord);
      lastEndTime = currentWord.endTime;
      currentWord = currentWord.next;
    }
    // Special case: if the string is empty and the last word hasn't ended by the start of this beat,
    // extend it to avoid blanks
    if (currentString === "" && lastEndTime && lastEndTime > currentBeat.startTime){
      currentString = lastText;
    }
    // Use Q as placeholder text until lyrics start, then blanks are OK
    //if (currentString === "" && player.video.firstWord.startTime > currentBeat.endTime){
    // currentString = "Q";
    //}
    let currentSuit = suits[currentBeat.index % 4];
    updateCardText(currentSuit, currentString);
    lastText = currentString;
  }
});

// Setting up controls
document.querySelector("a#play").addEventListener("click", (e) => {
  e.preventDefault();
  if (player) {
    if (player.isPlaying) {
      player.requestPause();
    }
    else {
      player.requestPlay();
    }
  }
  return false;
});

document.querySelector("a#stop").addEventListener("click", (e) => {
  e.preventDefault();
  if (player) {
    player.requestStop();
  }
  resetAnimation();
  return false;
})
</script>

<style>
  :root {
    --bpm: 134;
    --sec-per-beat: calc(60s / var(--bpm));
  }
    @keyframes throw {
      25% {
        z-index: 1;
        offset-distance: 0%;
        offset-rotate: 0deg;
      }
      100% {
        z-index: 0;
        offset-distance: 100%;
        offset-rotate: 70deg;
      }
    }
    @keyframes bounce {
      50% {
        transform: translateY(20px) rotateX(18deg) rotateY(21deg) rotateZ(-29deg);
      }
    }
    body::before {
      content: "";
      position: absolute;
      width: 1200vw;
      height: 700vw;
      top: -250vw;
      left: -350vw;
      z-index: -1;
      background: url("images/background_tile.png") top left repeat;
      transform: skew(10deg, 20deg);
    }
    body {
      margin: 0px;
      overflow: hidden;
    }

    .disabled {
      display: none;
    }

    .deck-position {
        position: absolute;
        top: 300px;
        left: 25%;
        transform: rotateX(18deg) rotateY(21deg) rotateZ(-29deg);
        transform-style: preserve-3d;
        animation: bounce var(--sec-per-beat) ease-in-out infinite;
        animation-delay: 0.25s;
    }
    .card {
        display: block;
        position: absolute;
        width: 300px;
        height: 420px;
        border: 1px solid black;
        margin: 0px;
        background-color: rgb(230, 221, 221);
        transform: translateZ(50px);
        offset-path: path("M 150 210 C 559 58 1323 166 3165 914");
        /* The offset path can't start at (0, 0), that would put the centre of the card in
        the top-left corner of the deck. But starting it at (width/2, height/2) also rotates it,
        because offset-path defaults to rotating things to line up with the path. This is
        actually useful for the animation, so it shouldn't be disabled. The solution is to
        undo that initial rotation, which has a value of atan(height/width) */
        offset-rotate: 0deg;
        animation: throw calc(4 * var(--sec-per-beat)) ease-in infinite;
    }
    .deck-front {
      display: block;
      position: absolute;
      width: 300px;
      height: 100px;
      top: 470px;
      border: 1px solid black;
      transform: rotateX(90deg) translateZ(100px);
      background-color: rgb(185, 178, 178);
    }
    .deck-right {
      display: block;
      position: absolute;
      width: 100px;
      height: 420px;
      left: -100px;
      border: 1px solid black;
      transform: rotateY(90deg) translateZ(50px);
      background-color: rgb(185, 178, 178);
    }
    .cardtext {
        font-size: 1.75em;
        white-space: nowrap;
        font-family: serif;
    }
    .cardtext::before {
      font-size: 1.5em;
    }
    .cardtext-top {
        position: relative;
        left: 10px;
        top: 0px;
        height: 0px;
        width: 0px;
    }
    .cardtext-bottom {
        position: relative;
        top: calc(100%);
        left: calc(100% - 10px);
        transform: rotate(180deg);
        height: 0px;
        width: 0px;
    }
    .image-zone {
        position: relative;
        width: 210px;
        height: 294px;
        left: 45px;
        top: 63px;
        border: 1px solid black;
    }

    .heart-card {
      animation-delay: calc(0 * var(--sec-per-beat));
    }
    .heart-card > .cardtext::before {
      content: "♥ ";
    }
    .heart-card > .cardtext {
      color: rgb(197, 32, 32);
    }

    .diamond-card {
      animation-delay: calc(2 * var(--sec-per-beat));
    }
    .diamond-card > .cardtext::before {
      content: "♦ ";
    }
    .diamond-card > .cardtext {
      color: rgb(197, 32, 32);
    }

    .club-card {
      animation-delay: calc(3 * var(--sec-per-beat));
    }
    .club-card > .cardtext::before {
      content: "♣ ";
    }
    .club-card > .cardtext {
      color: rgb(0, 0, 0);
    }

    .spade-card {
      animation-delay: calc(1 * var(--sec-per-beat));
    }
    .spade-card > .cardtext::before {
      content: "♠ ";
    }
    .spade-card > .cardtext {
      color: rgb(0, 0, 0);
    }

    #header {
      position: absolute;
      top: 50px;
      font-family: monospace;
      background-color: rgb(0, 0, 0, .5);
      padding: 15px;
      color: rgb(197, 32, 32);
    }
    #header > a {
      padding: 15px;
      color: rgb(197, 32, 32);
      text-decoration: none;
    }
    #header > a:hover {
      color: rgb(233, 38, 38);
    }
    #loading {
      font-family: fantasy;
      font-size: 3em;
    }
    /*The stop icon is a little larger than play and pause,
    setting the text size to be smaller as a workaround*/
    #play {
      font-size: 3em;
    }
    #stop {
      font-size: 2.5em;
    }
</style>

<!--One-lining these, they'll be replaced with JS during the animation -->
<style id="heart-cardtext-style">.heart-card > .cardtext::after{ content: "Q" }</style>
<style id="diamond-cardtext-style">.diamond-card > .cardtext::after{ content: "Q" }</style>
<style id="club-cardtext-style">.club-card > .cardtext::after{ content: "Q" }</style>
<style id="spade-cardtext-style">.spade-card > .cardtext::after{ content: "Q" }</style>
<style id="animation-state">.deck-position{animation-play-state: paused;} .card{animation-play-state: paused;}</style>

</head>

<body>
  <div id="media"></div>
  <div id="header">
    <a href="#" id="play" class="disabled">⏵</a>
    <a href="#" id="stop" class="disabled">⏹</a>
    <span id="loading">loading...</span>
  </div>
  <div class="deck-position">
    <div class="card club-card">
      <div class="cardtext cardtext-top"></div>
      <div class="cardtext cardtext-bottom"></div>
      <div class="image-zone club-image"></div>
    </div>
    <div class="card diamond-card">
      <div class="cardtext cardtext-top"></div>
      <div class="cardtext cardtext-bottom"></div>
      <div class="image-zone diamond-image"></div>
    </div>
    <div class="card spade-card">
      <div class="cardtext cardtext-top"></div>
      <div class="cardtext cardtext-bottom"></div>
      <div class="image-zone spade-image"></div>
    </div>
    <div class="card heart-card">
      <div class="cardtext cardtext-top"></div>
      <div class="cardtext cardtext-bottom"></div>
      <div class="image-zone heart-image"></div>
    </div>
    <div class="deck-front"></div>
    <div class="deck-right"></div>
  </div>
</body>
</html>